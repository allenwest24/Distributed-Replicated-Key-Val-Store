#!/usr/bin/env python

import sys, socket, select, time, json, random

# The method chosen to store is obviously a key-val struct.
kvs = {}
# When servers start up, they begin as followers.
state = "follower"
# This servers as the election timeout for this server.
elec_to = random.randint(2, 10)
# The term we are on.
term = 0
# Default of no.
voted_this_term = False
# If leader is unknown we use 'FFFF'.
leader = 'FFFF'
# Track our votes received in this term.
votes_for_me = 0

# Your ID number
my_id = sys.argv[1]
# The ID numbers of all the other replicas
replica_ids = sys.argv[2:]

# Connect to the network. All messages to/from other replicas and clients will
# occur over this socket
sock = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
sock.connect(my_id)

# We want to start with the current term as the last so that our election timeout picks the best server to start with.
last = time.time()

# Depending on terms specified elsewhere, this will start a new election for a leader.
def begin_election():
  global state
  global term
  global voted_this_term
  global votes_for_me
  # To begin an election, a follower increments its current term.
  term += 1
  # Transition to candidate state.
  state = 'candidate'
  votes_for_me += 1
  voted_this_term = True

  # Issue RequestVote RPC to each of the other servers in the cluster.
  requestvotemsg = {'type': 'rvm', 'src': my_id, 'dst': 'FFFF', 'leader': 'FFFF', 'term': term}
  sock.send(json.dumps(requestvotemsg))
  return

while True:
  ready = select.select([sock], [], [], 0.1)[0]

  if sock in ready:
    msg_raw = sock.recv(32768)

    if len(msg_raw) == 0: continue
    msg = json.loads(msg_raw)

    # If messages are of type GET or PUT.
    if msg['type'] in ['get', 'put']:
      #print '%s received a %s from %s' % (msg['dst'], msg['type'], msg['src'])
      msg_back = {}

      # If we received a PUT request.
      if msg['type'] == 'put':
        # Try to store locally.
        try:
          kvs[msg['key']] = msg['value']
          msg_back['type'] = 'fail' # TODO: Change this to 'ok' later on.
        # If the PUT fails.
        except:
          msg_back['type'] = 'fail'
        # Construct a resposne message.
        msg_back['src'] = msg['dst']
        msg_back['dst'] = msg['src']
        msg_back['leader'] = leader
        msg_back['MID'] = msg['MID']

      # If we received a GET request.
      elif msg['type'] == 'get':
        # Construct a response message.
        msg_back['src'] = msg['dst']
        msg_back['dst'] = msg['src']
        msg_back['leader'] = leader
        # If we have the key-val for this GET request.
        if msg['key'] in kvs:
          msg_back['type'] = 'fail' # TODO: Change this to 'ok' later on.
          msg_back['value'] = kvs[msg['key']] 
        # If the GET request fails.
        else:
          msg_back['type'] = 'fail'
                                
        msg_back['MID'] = msg['MID']

      sock.send(json.dumps(msg_back))

    # Handle heartbeats.
    elif msg['type'] == 'hb':
      last = time.time()
      leader = msg['leader']
      term = msg['term']
      state = 'follower'
      votes_for_me = 0
      voted_this_term = False
      print '%s received a HB from %s' % (msg['dst'], msg['src'])
    
    # If request to vote is received and we haven't voted, update term, vote, update that we have voted this term.
    elif msg['type'] == 'rvm':
      #leader = 'FFFF'
      if msg['term'] > term:
        leader = 'FFFF'
        voted_this_term = False
        term = msg['term']
      if not voted_this_term:
        vote = {'src': my_id, 'dst': msg['src'], 'type': 'vote', 'leader': leader, 'term': term}
        sock.send(json.dumps(vote))
        print("voted for", msg['src'])
      voted_this_term = True
    
    # If we receive a vote.
    elif msg['type'] == 'vote':
      print('recieved a vote!', str(my_id))
      if msg['term'] == term and leader == 'FFFF':
        print('terms match for this vote')
        votes_for_me += 1
        if votes_for_me >= len(replica_ids) / 2:
          # We won! Send an initial heart beat so everyone knows the results.
          heartbeat = {'src': my_id, 'dst': 'FFFF', 'leader': my_id, 'type': 'hb', 'term': term}
          sock.send(json.dumps(heartbeat))

          # Reset all values in preparation for a new election.
          state = 'leader'
          leader = my_id
          voted_this_term = False
          votes_for_me = 0
          print('new leader!', my_id)

    clock = time.time()
    # If a follower receives no communication in their election timeout window, there is no visible leader and begins an election.
    if clock - last > elec_to:
      print(str(clock - last))
      # Leaders send periodic heartbeats to all followers in order to maintain their authority.
      if state == 'leader':
        msg = {'src': my_id, 'dst': 'FFFF', 'leader': my_id, 'type': 'hb', 'term': term}
        sock.send(json.dumps(msg))
        print '%s sending a HB to %s' % (msg['src'], msg['dst'])
      # If a follower receives no communication in their election timeout window, there is no visible leader and we begin an election.
      elif state == 'follower':
        begin_election()
      last = clock
