#!/usr/bin/env python

import sys, socket, select, time, json, random

# The method chosen to store is obviously a key-val struct.
kvs = {}
# When servers start up, they begin as followers.
state = "follower"
# This servers as the election timeout for this server.
elec_to = random.randint(2, 10)
# The term we are on.
term = 0
# Default of no.
voted_this_term = False
# If leader is unknown we use 'FFFF'.
leader = 'FFFF'
# Track our votes received in this term.
votes_for_me = 0
# Your ID number
my_id = sys.argv[1]
# The ID numbers of all the other replicas
replica_ids = sys.argv[2:]

# Connect to the network. All messages to/from other replicas and clients will
# occur over this socket
sock = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
sock.connect(my_id)

last = time.time()

# Depending on terms specified elsewhere, this will start a new election for a leader.
def begin_election():
  global state
  global term
  global voted_this_term
  global votes_for_me
  # To begin an election, a follower increments its current term.
  term += 1
  # Transition to candidate state.
  state = 'candidate'
  votes_for_me += 1
  voted_this_term = True

  # Issue RequestVote RPC to each of the other servers in the cluster.
  requestvotemsg = {}
  requestvotemsg['type'] = 'rvm'
  requestvotemsg['src'] = my_id  
  requestvotemsg['dst'] = 'FFFF'
  requestvotemsg['leader'] = leader
  sock.send(json.dumps(requestvotemsg))
  return

while True:
  ready = select.select([sock], [], [], 0.1)[0]

  if sock in ready:
    msg_raw = sock.recv(32768)

    if len(msg_raw) == 0: continue
    msg = json.loads(msg_raw)

    # If messages are of type GET or PUT.
    if msg['type'] in ['get', 'put']:
      #print '%s received a %s from %s' % (msg['dst'], msg['type'], msg['src'])
      msg_back = {}

      # If we received a PUT request.
      if msg['type'] == 'put':
        # Try to store locally.
        try:
          kvs[msg['key']] = msg['value']
          msg_back['type'] = 'fail' # TODO: Change this to 'ok' later on.
        # If the PUT fails.
        except:
          msg_back['type'] = 'fail'
        # Construct a resposne message.
        msg_back['src'] = msg['dst']
        msg_back['dst'] = msg['src']
        msg_back['leader'] = msg['leader']
        msg_back['MID'] = msg['MID']

      # If we received a GET request.
      elif msg['type'] == 'get':
        # Construct a response message.
        msg_back['src'] = msg['dst']
        msg_back['dst'] = msg['src']
        msg_back['leader'] = msg['leader']
        # If we have the key-val for this GET request.
        if msg['key'] in kvs:
          msg_back['type'] = 'fail' # TODO: Change this to 'ok' later on.
          msg_back['value'] = kvs[msg['key']] 
        # If the GET request fails.
        else:
          msg_back['type'] = 'fail'
                                
        msg_back['MID'] = msg['MID']

      sock.send(json.dumps(msg_back))

    # Handle heartbeats.
    elif msg['type'] == 'hb':
      last = time.time()
      if leader != msg['leader']:
        leader = msg['leader']
      print '%s received a HB from %s' % (msg['dst'], msg['src'])
    
    # If request to vote is received and we haven't voted, update term, vote, update that we have voted this term.
    elif msg['type'] == 'rvm':
      if not voted_this_term:
        vote = {}
        vote['src'] = my_id
        vote['dst'] = msg['src']
        vote['type'] = 'vote'
        vote['leader'] = leader
      print("RECEIEVED YA REQ")
    
    # If we receive a vote.
    elif msg['type'] == 'vote':
      print('thanks')

    clock = time.time()
    # If a follower receives no communication in their election timeout window, there is no visible leader and begins an election.
    if clock - last > elec_to:
      print(str(clock - last))
      # Leaders send periodic heartbeats to all followers in order to maintain their authority.
      if state == 'leader':
        msg = {'src': my_id, 'dst': 'FFFF', 'leader': my_id, 'type': 'hb'}
        sock.send(json.dumps(msg))
        print '%s sending a HB to %s' % (msg['src'], msg['dst'])
      # If a follower receives no communication in their election timeout window, there is no visible leader and we begin an election.
      elif state == 'follower':
        begin_election()
      last = clock
