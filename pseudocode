#!/usr/bin/env python

import sys, socket, select, time, json, random

# The method chosen to store is obviously a key-val struct.
kvs = {}
# When servers start up, they begin as followers.
state = "follower"
# This servers as the election timeout for this server.
elec_to = round(random.uniform(1, 10), 6)
# The term we are on.
term = 0
# Default of no.
voted_this_term = False
# If leader is unknown we use 'FFFF'.
leader = 'FFFF'
# Track our votes received in this term.
votes_for_me = 0

# Your ID number
my_id = sys.argv[1]
# The ID numbers of all the other replicas
replica_ids = sys.argv[2:]

# Connect to the network. All messages to/from other replicas and clients will
# occur over this socket
sock = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
sock.connect(my_id)

# We want to start with the current term as the last so that our election timeout picks the best server to start with.
last = time.time()

# Depending on terms specified elsewhere, this will start a new election for a leader.
def begin_election():
  global state
  global term
  global voted_this_term
  global votes_for_me
  global leader

  print(str(leader) + " has been dethroned as leader.")
  print(str(my_id) + " becomes a candidate!")
  # To begin an election, a follower increments its current term.
  term += 1
  # Transition to candidate state.
  state = 'candidate'
  votes_for_me += 1
  voted_this_term = True
  leader = 'FFFF'

  # Issue RequestVote RPC to each of the other servers in the cluster.
  requestvotemsg = {'type': 'rvm', 'src': my_id, 'dst': 'FFFF', 'leader': 'FFFF', 'term': term}
  sock.send(json.dumps(requestvotemsg))
  return

while True:
  ready = select.select([sock], [], [], 0.1)[0]

  if sock in ready:
    msg_raw = sock.recv(32768)

    if len(msg_raw) == 0: continue
    msg = json.loads(msg_raw)

    if msg['type'] == 'redirect':
        print('fucking idiot')
    # If messages are of type GET or PUT.
    if msg['type'] in ['get', 'put']:
      #print '%s received a %s from %s' % (msg['dst'], msg['type'], msg['src'])
      msg_back = {}

      # If we received a PUT request.
      if msg['type'] == 'put':
        if msg['src'] == leader or leader == my_id:
          # Try to store locally.
          kvs[msg['key']] = msg['value']
          if leader == my_id:
            replicated_log = {'src': my_id, 'dst': 'FFFF', 'MID': msg['MID'], 'type': 'put', 'key': msg['key'], 'value': msg['value'], 'leader': leader}
            sock.send(json.dumps(replicated_log))
          msg_back['type'] = 'ok' 
          #print("put OK!")
        # Rdirect to actual leader.
        elif leader == 'FFFF':
          msg_back['type'] = 'fail'
          #print('put failure')
        else:
          msg_back['type'] = 'redirect'
        # Construct a response message.
        msg_back['src'] = my_id
        msg_back['dst'] = msg['src']
        msg_back['leader'] = leader
        msg_back['MID'] = msg['MID']

      # If we received a GET request.
      elif msg['type'] == 'get':
        if msg['src'] == leader or leader == my_id:
          # If we have the key-val for this GET request.
          if msg['key'] in kvs:
            msg_back['type'] = 'ok' 
            msg_back['value'] = kvs[msg['key']] 
            #print("get ok!")
          # If the GET request fails.
          else:
            msg_back['type'] = 'fail'
        elif leader == 'FFFF':
          msg_back['type'] = 'fail'
        else:
          msg_back['type'] = 'redirect'
        msg_back['src'] = my_id
        msg_back['dst'] = msg['src']
        msg_back['leader'] = leader
        msg_back['MID'] = msg['MID']

      sock.send(json.dumps(msg_back))

    # Handle heartbeats.
    elif msg['type'] == 'hb':
      last = time.time()
      leader = msg['leader']
      term = msg['term']
      state = 'follower'
      votes_for_me = 0
      voted_this_term = False
      #print '%s received a HB from %s' % (msg['dst'], msg['src'])
    
    # If request to vote is received and we haven't voted, update term, vote, update that we have voted this term.
    elif msg['type'] == 'rvm':
      #leader = 'FFFF'
      if msg['term'] > term:
        leader = 'FFFF'
        voted_this_term = False
        term = msg['term']
        state = 'follower'
        votes_for_me = 0
      if not voted_this_term:
        vote = {'src': my_id, 'dst': msg['src'], 'type': 'vote', 'leader': leader, 'term': term}
        sock.send(json.dumps(vote))
        #print("voted for", msg['src'])
      voted_this_term = True
    
    # If we receive a vote.
    elif msg['type'] == 'vote':
      if msg['term'] == term and leader == 'FFFF':
        votes_for_me += 1
        if votes_for_me >= len(replica_ids) / 2 and state == "candidate":
          # We won! Send an initial heart beat so everyone knows the results.
          heartbeat = {'src': my_id, 'dst': 'FFFF', 'leader': my_id, 'type': 'hb', 'term': term}
          sock.send(json.dumps(heartbeat))
          print(my_id + " has won the election. A heartbeat has been sent out")

          # Reset all values in preparation for a new election.
          state = 'leader'
          leader = my_id
          voted_this_term = False
          votes_for_me = 0

    clock = time.time()
    # If a follower receives no communication in their election timeout window, there is no visible leader and begins an election.
    if clock - last > elec_to:
      # Leaders send periodic heartbeats to all followers in order to maintain their authority.
      if state == 'leader':
        msg = {'src': my_id, 'dst': 'FFFF', 'leader': my_id, 'type': 'hb', 'term': term}
        sock.send(json.dumps(msg))
        print '%s sending a HB to %s' % (msg['src'], msg['dst'])
      # If a follower receives no communication in their election timeout window, there is no visible leader and we begin an election.
      elif state == 'follower':
        begin_election()
      last = clock
